pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/ownership/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
//import "@openzeppelin/contracts/token/ERC20/ERC20Mintable.sol";
import "./interfaces/CulteDeposit.sol";
import "./interfaces/Tentacle.sol";
import "./interfaces/TokenRecipient.sol";


/**
 * @title CLT tentacle (deposit) contract
 * @notice This contract is generated by the deposit core, and
 * provides a unique address for a user to deposit eth and tokens
 */
contract Tentacle is TokenRecipient {
    ICulteDeposit core = ICulteDeposit(msg.sender);
    address payable coreAddress = msg.sender;
    string public uid;

    /**
     * @notice Constructor
     * @param _uid Identifier of the user who owns the address
     */
    constructor(string memory _uid) public {
        uid = _uid;
    }

    /**
     * @notice Fallback
     * @notice Transfers values stright to the core.
     */
    function() external payable {
        require(msg.value > 0, "No value sent");
        coreAddress.transfer(msg.value);
    }

    /**
     * @notice Function used to deposit ERC20 tokens
     * Will depostit the whole allowance
     * @param from Address from the token sender (who approved the transfer)
     * @param token Address of the token
     */
    function depositERC20(address from, address token) public {
        ERC20 tokenContract = ERC20(token);
        uint256 value = tokenContract.allowance(from, address(this));
        require(value > 0, "No allowance");
        require(
            tokenContract.transferFrom(from, address(this), value),
            "transferFrom failed"
        );
        _sendTokens(tokenContract, value);
    }

    /**
     * @notice Rescue Tokens
     * Function to move tokens incorrectly sent to the contract (transfer) to the core
     * @param token Address of the token
     */
    function rescueTokens(address token) public returns (bool success) {
        ERC20 tokenContract = ERC20(token);
        uint256 value = tokenContract.balanceOf(address(this));
        require(value > 0, "No token balance");
        _sendTokens(tokenContract, value);
        success = true;
    }

    /**
     * @notice _sendTokens (internal)
     * @param tokenContract Address of the token
     * @param value Value that will be sent
     */
    function _sendTokens(ERC20 tokenContract, uint256 value) internal {
        tokenContract.approve(coreAddress, value);
        core.receiveTokens(address(tokenContract), value);
    }

    /**
     * @notice receiveApproval
     * ERC223 token fallback, allows 1tx deposits
     * @param from Address of the sender
     * @param value Value that will be deposited
     * @param token Address of the token
     * @param extraData unused
     */
    function receiveApproval(
        address from,
        uint256 value,
        address token,
        bytes32 extraData
    ) public {
        depositERC20(from, token);
    }
}

/**
 * @title Culte Deposit Core
 * @notice This contract generates user deposit addresses and
 * will receive all funds deposited. Will also emit all events needed.
 */
contract CulteDepositCore is Ownable {
    mapping(address => string) tentacles;

    event Payment(uint256 value, string purchaseId, address tokenAddress);
    event Deposit(uint256 value, address uid, address tokenAddress);
    event Withdrawal(uint256 value, string uid, address tokenAddress);
    event NewTentacle(address tentacle, string uid);

    /**
     * @notice Fallback
     * @notice Emits deposit event
     */
    function() external payable {
        emit Deposit(msg.value, msg.sender, address(0x0));
    }

    /**
     * @notice receiveTokens, called by tentacles to inform tokens were deposited
     * @param token Address of the token
     * @param value Value that will be deposited
     */
    function receiveTokens(address token, uint256 value) public {
        ERC20 tokenContract = ERC20(token);
        require(
            tokenContract.transferFrom(msg.sender, address(this), value),
            "transferFrom failed"
        );
        emit Deposit(value, msg.sender, token);
    }

    /**
     * @notice receivePayment, called when a purchase is made
     * @param token Address of the token
     * @param value Value that will be deposited
     * @param purchaseId Id of the purchase
     */
    function receivePayment(
        address token,
        uint256 value,
        string memory purchaseId
    ) public payable {
        if (msg.value > 0) {
            require(
                token == address(0),
                "Sending ETH and tokens in same tx no allowed"
            );
            emit Payment(msg.value, purchaseId, token);
        } else if (token != address(0x0)) {
            ERC20 tokenContract = ERC20(token);
            require(
                tokenContract.transferFrom(msg.sender, address(this), value),
                "transferFrom failed"
            );
            emit Payment(value, purchaseId, token);
        }
    }

    /**
     * @notice newTentacle, called to create a deposit address
     * @param uid Id of the user
     */
    function newTentacle(string memory uid) public onlyOwner {
        _newTentacle(uid);
    }

    /**
     * @notice batchNewTentacles
     * @param uid Id of the users
     */
    function batchNewTentacles(string[] memory uid) public onlyOwner {
        require(uid.length > 0, "No ids provided");
        for (uint256 i = 0; i < uid.length; i++) {
            _newTentacle(uid[i]);
        }
    }

    /**
     * @notice _newTentacle, internal function to create a deposit address
     * @param uid Id of the user
     */
    function _newTentacle(string memory uid) internal {
        Tentacle feeler = new Tentacle(uid);
        tentacles[address(feeler)] = uid;
        emit NewTentacle(address(feeler), uid);
    }

    /**
     * @notice rescueTokens, get tokens stuck in deposit contracts
     * @param token Address of the token
     * @param tentacleAddress Address of the deposit contract
     */
    function rescueTokens(address token, address payable tentacleAddress)
        public
    {
        Tentacle tentacle = Tentacle(tentacleAddress);
        tentacle.rescueTokens(token);
    }

    /**
     * @notice Withdraw
     * @param uid Id of the user
     * @param userAddress Address that will receive the withdraw
     * @param token Address of the token, 0x0 for ether
     * @param value Value that will be withdrawn
     */
    function withdraw(
        string calldata uid,
        address payable userAddress,
        address token,
        uint256 value
    ) external onlyOwner {
        if (token == address(0x0)) {
            address(userAddress).transfer(value);
        } else {
            ERC20 tokenContract = ERC20(token);
            require(
                tokenContract.transfer(userAddress, value),
                "transfer failed"
            );
        }
        emit Withdrawal(value, uid, token);
    }
}
